---
layout: page
title: L18 RISC-V Single Cycle Datapath I
permalink: /L18
nav_order: 18





---



# Lecture 18: RISC-V Single Cycle Datapath I

# Building a RISC-V Processor

### 制作 RISC-V 处理器

## 体系结构层次当前构建的部分

当前制作 RISC-V 处理器的步骤集中在**硬件架构描述**和**逻辑电路描述**这两个层次：

1. **硬件架构描述**
   - **CPU 元件和阶段**：设计处理器的基本组件和各个阶段（如取指令、译码、执行、访存和写回）。
   - **R 型数据路径**：
     - **add 数据路径**：设计用于执行加法指令的数据路径。
     - **sub 数据路径**：设计用于执行减法指令的数据路径。
   - **带立即数的数据路径**：如 `addi` 指令的数据路径。

2. **逻辑电路描述**
   - **数据路径的具体实现**：使用逻辑门和触发器设计具体的电路，实现 RISC-V 指令集的功能。
   - **组合逻辑设计**：设计 ALU 等基本运算单元。
   - **控制逻辑设计**：设计控制信号生成电路，管理数据路径中的数据流。

### 补充说明

- **图中的分层结构**：图中展示了从高层次语言到硬件实现的抽象层次，这在计算机体系结构中是一个重要的概念。每一层都依赖于下层的实现，同时为上层提供功能支持。
- **当前构建阶段**：当前正在从底层的**逻辑电路描述**和**硬件架构描述**开始，逐步向上构建。具体来说，正在实现 RISC-V 的数据路径、控制单元和基本运算单元（如 ALU）。
- **目标**：最终目标是完成一个能够执行 RISC-V 指令集的处理器，这包括所有必要的硬件组件和数据路径设计。

## 如何构建单核处理器？

处理器（CPU）是计算机中执行所有数据操作和决策的核心部分。

### 处理器的组成部分

- **数据路径（Datapath）**：
  - 数据路径是处理器的一部分，包含执行处理器所需操作的硬件组件。这些组件包括程序计数器（Program Counter, PC）、寄存器（Registers）和算术逻辑单元（Arithmetic Logic Unit, ALU）。
  - 在图中，数据路径部分被标记为粉红色区域。它包含了所有处理操作的具体实现。

- **控制单元（Control）**：
  - 控制单元是处理器的“大脑”，它决定数据路径需要执行哪些操作。控制单元发送各种控制信号来指挥数据路径中的各个组件。
  - 图中的控制单元被标记为黄色区域，它与数据路径一起构成了处理器的整体功能。

### 处理器与其他部件的交互

- **存储器（Memory）**：
  - 处理器通过地址总线、数据总线与存储器进行交互，读取指令和数据，以及写入数据。存储器包含指令存储区和数据存储区。
  - 图中展示了处理器如何通过启用/读/写信号与存储器交互。

- **输入/输出（Input/Output）**：
  - 处理器也可以与输入和输出设备交互，通过总线传输数据。

![image-20240803152304636]({{ site.baseurl }}/docs/assets/image-20240803152304636.png)

## 目标：设计硬件以执行所有 RV32I 指令

### RISC-V 指令集参考卡

- 图中展示了 RISC-V 指令集的各个类别，包括移位指令、算术指令、加载和存储指令、分支指令、逻辑指令、跳转和链接指令等。每个类别下列出了具体的指令及其操作码。
- RV32I 指令集是 RISC-V 指令集的一部分，处理器需要实现这些指令，以完成所有的计算任务。

### 实现 RISC-V 指令集的处理器

- 图中展示了一个实际的 RISC-V 处理器板卡（HiFive Unmatched），它可以执行 RISC-V Linux 操作系统。处理器芯片被突出显示，说明了实际硬件实现的具体样例。

![image-20240803152331761]({{ site.baseurl }}/docs/assets/image-20240803152331761.png)

总结来说，这部分内容详细讲解了如何构建一个单核处理器，包括处理器的核心组成部分（数据路径和控制单元）、处理器与存储器及输入输出设备的交互方式，以及目标实现的 RISC-V 指令集的各个类别和具体指令。通过这些解释，我们可以更好地理解处理器的设计和实现过程。

# CPU Elements and stages

## 组合逻辑块

今天我们将所有组合逻辑子电路看作框图。

### 组合逻辑块回顾

- **1位宽2输入多路复用器**：
  - 图示展示了一个1位宽2输入多路复用器的电路，使用两个与门（AND）、一个或门（OR）和一个非门（NOT）构成。

- **N位加法器**：
  - 图中展示了一个N位加法器的电路，多个1位加法器串联起来以处理多位的加法运算。

- **简单的ALU**：
  - 一个简单的算术逻辑单元（ALU），可以执行加法、减法、与操作（AND）和或操作（OR）。

### 本节使用框图

- **32位宽2输入多路复用器**：
  - 图中展示了一个32位宽2输入多路复用器，使用多个1位宽多路复用器组合而成。选择信号S决定输出是来自输入A还是输入B。

- **32位加法器**：
  - 图中展示了一个32位加法器，可以处理32位的加法运算，包括进位输入（CarryIn）和进位输出（CarryOut）。

- **ALU（算术逻辑单元）**：
  - 可以执行多种操作，包括加法、减法、与操作和或操作。ALU操作由ALU操作码（AluOp）选择。

![image-20240803154222453]({{ site.baseurl }}/docs/assets/image-20240803154222453.png)

## 单指令每周期RISC-V机器

CPU由两种子电路组成：组合逻辑块和状态元素。

### 时钟每个周期执行一条指令

- **组合逻辑驱动**：
  - 每个时钟周期，计算机执行一条指令：
    - 状态元素的当前输出驱动组合逻辑的输入。
    - 组合逻辑的输出设置在下一个时钟上升沿之前状态元素的输入。

- **时钟上升沿**：
  - 在时钟上升沿，所有状态元素使用组合逻辑的输出进行更新。
  - 执行移动到下一个时钟周期。

## RV32I ISA所需的状态元素

### 程序计数器（PC）

- **程序计数器**：
  - 程序计数器（PC）是处理器的状态元素之一，用于跟踪指令的地址。

### 寄存器文件（Register File）

- **寄存器文件**：
  - 寄存器文件包含多个寄存器，用于存储临时数据和操作数。

### 存储器（Memory）

- **指令存储器（IMEM）和数据存储器（DMEM）**：
  - 指令存储器用于存储指令，数据存储器用于存储数据。

### 在CPU执行期间，每条RV32I指令读取和/或更新这些状态元素

- **处理器数据路径**：
  - 数据路径包括程序计数器、寄存器文件和算术逻辑单元（ALU）。
  - 控制单元负责协调和控制这些状态元素和数据路径的操作。

![image-20240803154107238]({{ site.baseurl }}/docs/assets/image-20240803154107238.png)

## 状态元素（1/3）：程序计数器

### 程序计数器（Program Counter）

- **程序计数器的功能**：
  - 程序计数器（PC）是一个32位的寄存器，用于存储当前执行指令的地址。

- **输入**：
  - **N位数据输入总线**：数据输入总线用于接收新地址。
  - **写使能（Write Enable）控制位**：用于控制是否写入新地址，高电平（1）表示写入，低电平（0）表示不写入。

- **输出**：
  - **N位数据输出总线**：输出当前存储的地址。

- **行为**：
  - 如果写使能在时钟上升沿为高电平（1），则将数据输入的值设置为数据输出。
  - 在其他时间，数据输出保持不变，输出当前值。

![image-20240803154733866]({{ site.baseurl }}/docs/assets/image-20240803154733866.png)

## 状态元素（2/3）：寄存器文件

### 寄存器文件（Register File）

- **寄存器文件包含32个寄存器**：
  - 每个寄存器都是32位的。
  - 寄存器文件通过5位寄存器编号访问寄存器。

- **输入**：
  - **一个32位输入数据总线（dataW）**：用于写入数据。
  - **三个5位选择总线（rs1, rs2, rsW）**：用于选择读取和写入的寄存器。
  - **寄存器写使能控制位（RegWEn）**：控制是否进行写入操作。

- **输出**：
  - **两个32位输出数据总线（data1和data2）**：用于输出读取的数据。

- **时钟行为**：
  - 写操作发生在时钟上升沿。
  - 读操作类似于组合逻辑块：当rs1和rs2有效时，data1和data2在访问时间后有效。

- **寄存器文件的行为**：
  - 对于读操作，寄存器文件的行为类似于组合逻辑块。
  - 对于写操作，时钟信号仅在写入时起作用。

![image-20240803154808297]({{ site.baseurl }}/docs/assets/image-20240803154808297.png)

## 状态元素（3/3）：存储器

### 存储器（Memory）

- **存储器的基本信息**：
  - 存储器是一个32位字节地址的存储空间。
  - 存储器的访问单位是32位字。

- **输入**：
  - **32位数据输入总线（dataW）**：用于写入数据。
  - **32位地址总线（addr）**：用于选择要访问的存储单元。
  - **存储器读/写控制位（MemRW）**：控制是读操作还是写操作。

- **输出**：
  - **32位数据输出总线（dataR）**：用于输出读取的数据。

- **行为**：
  - 读操作：地址总线选择要读取的存储单元，数据输出总线输出对应的数据。
  - 写操作：当MemRW为高电平（1）时，在时钟上升沿将数据输入总线的数据写入选定的地址单元。

- **存储器的特殊行为**：
  - 类似于寄存器文件，时钟信号仅在写入时起作用。
  - 如果MemRW为0，且地址有效，则在访问时间后数据有效，表现为组合逻辑块。

![image-20240803154941992]({{ site.baseurl }}/docs/assets/image-20240803154941992.png)

## “两个”存储器：IMEM, DMEM

### 存储器抽象

在当前的抽象中，存储器同时包含指令和数据，位于一个连续的32位内存空间中。在我们的处理器中，我们将使用两个“独立”的存储器：

- **IMEM**：只读存储器，用于获取指令。
- **DMEM**：用于加载（读取）和存储（写入）数据字的存储器。

### 细节解释

- **IMEM（指令存储器）**：
  - 只读存储器，总是表现为组合逻辑块。
  - 如果`addr`有效，则在访问时间后`instr`有效。
  
- **DMEM（数据存储器）**：
  - 读取和写入数据字的存储器。
  - 使用地址`addr`选择要访问的存储单元。
  - `MemRW`控制读写操作，时钟信号在写入时起作用。

由于IMEM是只读的，所以它总是表现为一个组合逻辑块，而DMEM则可以读写，并在时钟上升沿控制写操作。

![image-20240803155221153]({{ site.baseurl }}/docs/assets/image-20240803155221153.png)

## 分阶段设计数据路径

### 任务：执行指令

- 所有必要的操作，从获取指令开始。

### 问题

- 一个单一的“整体”块将会笨重且低效。

### 解决方案

- 将过程分解为多个阶段，然后连接这些阶段以创建完整的数据路径。

### 优点

- **小阶段设计更容易**：每个阶段的设计和调试更简单。
- **模块化**：可以独立优化每个阶段，而不影响其他部分。

![image-20240803155343167]({{ site.baseurl }}/docs/assets/image-20240803155343167.png)

### 数据路径设计示意图

- **PC**：程序计数器，控制指令的地址。
- **IMEM**：指令存储器，存储指令。
- **Reg1**：寄存器文件，用于存储临时数据。
- **DMEM**：数据存储器，存储数据。
- **组合逻辑**：处理逻辑操作。
- **时钟信号（clk）**：同步各个部分的操作。

通过分阶段设计，可以使每个部分更加高效和模块化，便于优化和调试。

## 指令执行的五个基本阶段

### 1. 取指阶段（Instruction Fetch，IF）

在这个阶段，程序计数器（PC）会向指令存储器（IMEM）发送当前指令地址，指令存储器根据地址读取对应的指令并将其提供给下一个阶段。

### 2. 指令译码阶段（Instruction Decode，ID）和读取寄存器

在这个阶段，读取到的指令被译码，以确定指令类型和操作数。此阶段还会从寄存器文件（RegFile）中读取操作数。

### 3. 执行阶段（Execute，EX）

在执行阶段，算术逻辑单元（ALU）根据指令执行相应的算术或逻辑操作，如加法、减法、与、或等操作。

### 4. 存储访问阶段（Memory Access，MEM）

在这个阶段，若指令需要访问数据存储器（DMEM），则会进行相应的读或写操作。比如，对于加载指令，DMEM会读取数据；对于存储指令，DMEM会写入数据。

### 5. 写回寄存器阶段（Write Back，WB）

在最后一个阶段，ALU或DMEM的结果会写回到寄存器文件中，以供后续指令使用。

我们将实现一个单周期处理器，这意味着所有阶段都将在一个时钟周期内完成。

![image-20240803155459258]({{ site.baseurl }}/docs/assets/image-20240803155459258.png)

## 并非所有指令都需要所有五个阶段！

并非所有指令都需要经过所有这五个阶段。控制逻辑会根据具体的指令选择需要的数据路径。例如：

- 立即数操作可能不需要访问存储器阶段。
- 简单的加法或逻辑操作可能只需要前三个阶段。

### 控制逻辑的作用

控制逻辑负责选择指令执行过程中需要的数据路径，并控制MUX选择器、ALU操作选择器、写使能等信号。通过有效地控制这些信号，可以确保处理器高效、准确地执行各种类型的指令。

![image-20240803155525778]({{ site.baseurl }}/docs/assets/image-20240803155525778.png)

# R-Type: `add` datapath

### 加法指令实现过程

假设我们在 RISC-V ISA 中有一个单独的加法指令：

```
add rd, rs1, rs2
```

这个指令的格式如图所示，其中 `rd` 是目的寄存器，`rs1` 和 `rs2` 是源寄存器。

![image-20240804101412059]({{ site.baseurl }}/docs/assets/image-20240804101412059.png)

### 加法指令对处理器状态的两个变化

1. **寄存器文件（RegFile）**：
   - 执行 `Reg[rd] = Reg[rs1] + Reg[rs2]` 操作，即将两个源寄存器的值相加，并将结果存储到目的寄存器 `rd` 中。

2. **程序计数器（PC）**：
   - 执行 `PC = PC + 4` 操作，即将程序计数器增加 4，以指向下一条指令。

### 加法指令的数据路径

图中展示了加法指令的数据路径：

- 程序计数器（PC）在每次指令执行后增加 4。
- 从指令存储器（IMEM）读取当前指令，并将其分割以索引到寄存器文件（RegFile）中。
- 从寄存器文件中读取 `rs1` 和 `rs2` 寄存器的值，送入 ALU（算术逻辑单元）。
- ALU 执行加法操作，并将结果写回到目的寄存器 `rd`。

通过这种方式，我们实现了加法指令的数据路径。

![image-20240804101727459]({{ site.baseurl }}/docs/assets/image-20240804101727459.png)

## 迭代构建完整的数据路径计划

当前，我们将内存部分暂时断开。通过逐步添加和调试各个部分，最终我们将构建支持完整 RV321 ISA 的数据路径。在下一讲结束时，我们将完成这个数据路径的构建，包括指令存储器和数据存储器的连接和控制逻辑的实现。

![image-20240804101835822]({{ site.baseurl }}/docs/assets/image-20240804101835822.png)

# R-Type: `sub` Datapath

## 减法指令

### 假设我们的 ISA 现在有两个指令：加法（add）和减法（sub）

在 RISC-V ISA 中，加法和减法指令的编码格式如下：

- **加法指令（add）**：
  - `funct7`: 0000000
  - `rs2`, `rs1`, `funct3`, `rd`: 对应各自的寄存器
  - `opcode`: 0110011

- **减法指令（sub）**：
  - `funct7`: 0100000
  - `rs2`, `rs1`, `funct3`, `rd`: 对应各自的寄存器
  - `opcode`: 0110011

![image-20240804102330108]({{ site.baseurl }}/docs/assets/image-20240804102330108.png)

## 减法指令的实现

减法指令的实现与加法指令非常相似，唯一的区别在于 ALU 现在是执行减法操作而不是加法操作：

- **寄存器文件（RegFile）**：
  - 执行 `Reg[rd] = Reg[rs1] - Reg[rs2]` 操作，即从源寄存器 `rs1` 中减去源寄存器 `rs2` 的值，并将结果存储到目的寄存器 `rd` 中。

- **程序计数器（PC）**：
  - 执行 `PC = PC + 4` 操作，即将程序计数器增加 4，以指向下一条指令。

### 指令位 `inst[30]` 在加法和减法之间进行选择

- **控制逻辑（Control Logic）**：
  - `inst[30]` 位用于在加法和减法操作之间进行选择。
  - 当 `inst[30]` 为 0 时，执行加法操作；
  - 当 `inst[30]` 为 1 时，执行减法操作。

## 减法指令的数据路径

图中展示了减法指令的数据路径：

- 程序计数器（PC）在每次指令执行后增加 4。
- 从指令存储器（IMEM）读取当前指令，并将其分割以索引到寄存器文件（RegFile）中。
- 从寄存器文件中读取 `rs1` 和 `rs2` 寄存器的值，送入 ALU（算术逻辑单元）。
- ALU 根据 `inst[30]` 位选择执行加法或减法操作，并将结果写回到目的寄存器 `rd`。

通过这种方式，我们实现了减法指令的数据路径，并利用控制逻辑在加法和减法操作之间进行选择。

![image-20240804102504487]({{ site.baseurl }}/docs/assets/image-20240804102504487.png)

## 控制 vs 数据路径

控制和数据路径是组成CPU的两个抽象概念。在底层，这两者都是通过组合逻辑和/或状态元件设计的。

- **控制**：负责告诉数据路径该做什么。它从指令存储器读取指令并进行解码。
- **数据路径**：执行控制逻辑指示的操作，实际进行数据处理。

**数据路径**

- **程序计数器（PC）**：每次执行指令后递增，指向下一条指令。
- **指令存储器（IMEM）**：存储指令，根据PC提供当前指令。
- **寄存器文件（RegFile）**：存储临时数据，从中读取操作数，并将结果写回。
- **算术逻辑单元（ALU）**：执行具体的算术和逻辑操作。
- **数据存储器（DMEM）**：存储数据，进行数据的读写操作。

## 支持所有R型指令

为了支持所有R型指令，控制逻辑需要解码指令的`funct3`和`funct7`字段，并设置ALU控制线（ALUSel）来选择适当的ALU功能。

下表列出了RISC-V中一些常见的R型指令及其对应的`funct3`、`funct7`和操作码（opcode）：

![image-20240804102808423]({{ site.baseurl }}/docs/assets/image-20240804102808423.png)

控制逻辑通过解码这些字段，设置ALU的控制信号（ALUSel），选择合适的操作。

通过这种方式，控制逻辑和数据路径协同工作，完成指令的执行过程。控制逻辑相当于“任务控制中心”，负责指挥数据路径这一“空间站”完成各项操作。

# Datapath with immediates: `addi`

## 实现 `addi` 指令

假设我们在 RISC-V ISA 中添加了一条新的指令：`addi`，这是 I 型格式指令。其格式如下：

```
addi rd, rs1, imm
```

其中，`rd` 是目标寄存器，`rs1` 是源寄存器，`imm` 是立即数。指令的编码如下：

![image-20240804104020987]({{ site.baseurl }}/docs/assets/image-20240804104020987.png)

具体为：

- `imm[11:0]`：12 位立即数
- `rs1`：源寄存器
- `funct3`：功能码
- `rd`：目标寄存器
- `opcode`：操作码

### `addi` 指令的功能

`addi` 指令与 `add` 指令类似，但需要将立即数 `imm` 与寄存器 `rs1` 的值相加，而不是两个寄存器的值相加。指令执行后，结果存储在目标寄存器 `rd` 中，程序计数器 `PC` 增加 4 指向下一条指令。具体为：

```
Reg[rd] = Reg[rs1] + imm
PC = PC + 4
```

## 数据路径需求

要实现 `addi` 指令的数据路径，我们需要在 ALU 的输入 B 端提供立即数 `imm`，而不是寄存器 `rs2` 的值。

### 数据路径修改

1. **程序计数器（PC）**：
   - PC 每次增加 4，指向下一条指令。

2. **指令存储器（IMEM）**：
   - 根据 PC 提供当前指令，并将其拆分以索引寄存器文件。

3. **寄存器文件（RegFile）**：
   - 从寄存器中读取 `rs1` 的值。

4. **立即数生成器**：
   - 从指令的 `imm` 字段生成 12 位立即数。

5. **算术逻辑单元（ALU）**：
   - 接收 `rs1` 的值和立即数 `imm`，并执行加法操作。

6. **控制逻辑**：
   - 控制信号 `ALUSel` 选择加法操作。
   - 控制寄存器文件写使能信号 `RegWEn`。

![image-20240804104447005]({{ site.baseurl }}/docs/assets/image-20240804104447005.png)

### 具体数据路径

如图所示，我们需要将立即数 `imm` 输入到 ALU 的 B 端：

- **IMEM** 根据 PC 提供指令，并将指令拆分成 `rs1`、`rd` 和 `imm`。
- **RegFile** 读取 `rs1` 的值并提供给 ALU 的 A 端。
- **立即数生成器** 生成立即数 `imm` 并提供给 ALU 的 B 端。
- **ALU** 进行加法运算，将结果写入目标寄存器 `rd`。

通过这些修改，数据路径能够支持 `addi` 指令的执行。



## 1. 新的多路复用器（MUX）选择 ALU 的立即数输入

为了实现 `addi` 指令，需要在数据路径中添加一个新的多路复用器（MUX）来选择立即数作为 ALU 的输入 B。如下图所示：

![image-20240804104610416]({{ site.baseurl }}/docs/assets/image-20240804104610416.png)

- **控制信号 Bsel**：
  - 当控制信号 Bsel = 1 时，选择生成的立即数 `imm` 作为 ALU 的输入 B。
  - 控制逻辑根据指令类型决定 Bsel 的值。

### 数据路径修改：

1. **增加多路复用器（MUX）**：
   - 多路复用器的一个输入是寄存器 `rs2` 的值，另一个输入是立即数 `imm`。
   - 控制信号 Bsel 选择哪一个输入送到 ALU 的 B 端。

2. **控制逻辑**：
   - 控制信号 Bsel 和 ALUSel 由控制逻辑生成，用于选择 ALU 操作的输入和类型。

### 数据路径示意图：

- IMEM 提供指令，并将指令拆分成 `rs1`、`rd` 和 `imm`。
- RegFile 读取 `rs1` 的值，并提供给 ALU 的 A 端。
- 新的多路复用器根据控制信号 Bsel 选择 ALU 的 B 端输入（`rs2` 或 `imm`）。

## 2. 新的立即数生成模块

为了从指令中提取立即数 `imm`，需要增加一个新的立即数生成模块。如下图所示：

![image-20240804104727776]({{ site.baseurl }}/docs/assets/image-20240804104727776.png)

- **立即数生成模块（Imm. Gen.）**：
  - 从指令的 `imm` 字段生成 32 位立即数 `imm`。
  - 将生成的立即数送入新的多路复用器供 ALU 使用。

### 数据路径修改：

1. **增加立即数生成模块**：
   - 立即数生成模块从指令中提取 `imm[11:0]`，并扩展为 32 位立即数。

2. **控制逻辑**：
   - 控制信号 ImmSel 控制立即数生成模块的工作。

### 数据路径示意图：

- 指令存储器（IMEM）根据 PC 提供当前指令。
- 立即数生成模块从指令中提取立即数 `imm[11:0]` 并扩展为 32 位。
- 新的多路复用器根据控制信号 Bsel 选择 ALU 的 B 端输入（`rs2` 或 `imm`）。
- ALU 执行加法操作，并将结果写入目标寄存器 `rd`。

通过这些修改，数据路径能够支持 `addi` 指令的执行。



## 跟踪/点亮 `addi` 数据路径

为了更好地理解 `addi` 指令的数据路径，我们可以逐步跟踪信号的流动，如下图所示：

![image-20240804105857392]({{ site.baseurl }}/docs/assets/image-20240804105857392.png)

这张图展示了一个`addi`指令的数据路径（datapath），用于解释指令如何在计算机的不同组件之间传递。`addi`指令格式是 `addi rd, rs1, imm`，其中：

- `rd`：目标寄存器
- `rs1`：源寄存器
- `imm`：立即数

### 详细解释

1. **程序计数器（PC）**：
   - 程序计数器持有当前指令的地址。
   - 每次指令执行后，PC会增加4（假设每条指令长度为4个字节），以指向下一条指令的地址。

2. **指令内存（IMEM）**：
   - 从程序计数器（PC）获取当前指令的地址，并从指令内存中读取该指令。
   - 输出`inst`为当前指令。

3. **立即数生成（Imm. Gen）**：
   - 从指令的某些位（`inst[31:20]`）生成一个32位的立即数`imm`。

4. **寄存器文件（Reg[]）**：
   - 根据指令中的字段读取寄存器值。对于`addi`指令：
     - `rs1`字段（`inst[19:15]`）指定源寄存器。
     - `rd`字段（`inst[11:7]`）指定目标寄存器。
   - 从寄存器文件读取`rs1`的值，得到`dataR1`。

5. **控制信号（Control Logic）**：
   - 控制信号`Bsel=1`选择立即数作为ALU的B输入。
   - 控制信号`ALUSel=Add`选择加法运算。

6. **算术逻辑单元（ALU）**：
   - ALU执行加法运算，输入A是寄存器`rs1`的值，输入B是立即数。
   - ALU的输出是`rs1`和`imm`的和。

7. **写回寄存器**：
   - ALU的输出被写回到目标寄存器`rd`中。

## 立即数生成模块设计

立即数生成模块（Imm. Gen.）的作用是从指令中提取立即数 `imm` 并扩展为 32 位立即数。如下图所示：

![image-20240804110129370]({{ site.baseurl }}/docs/assets/image-20240804110129370.png)

- **指令**：32 位指令由以下字段组成：
  - `imm[11:0]`：立即数字段的低 12 位。
  - `rs1`：源寄存器 1。
  - `funct3`：功能码 3。
  - `rd`：目标寄存器。
  - `opcode`：操作码。

- **立即数生成**：
  - **低 12 位**：从指令的 `imm[11:0]` 字段复制到立即数的低 12 位。
  - **高 20 位**：将指令的第 31 位符号扩展到立即数的高 20 位。

### 具体步骤：

1. **从指令中提取 `imm[11:0]` 字段**。
2. **将指令的第 31 位符号扩展到 `imm[31:12]`**，形成 32 位立即数 `imm`。

通过这些步骤，立即数生成模块可以生成一个 32 位的立即数 `imm`，并将其提供给 ALU 用于 `addi` 操作。

## Your Own Design

1. **我们应该使用主 ALU 来计算 `PC=PC+4` 以节省一些门电路**。
   - **错误**（F）：在实际设计中，为了节省ALU的使用频率以及避免潜在的时序问题，通常会使用专门的加法器来计算 `PC=PC+4`。虽然在理论上可以使用ALU来完成这项操作，但为了简化设计并提高性能，往往会选择使用独立的硬件单元。
2. **ALU 是一个同步状态元素**。
   - **错误**（F）：ALU 并不是一个状态元素，它是一个组合逻辑电路，它根据输入立即产生输出。状态元素是像寄存器这样的硬件单元，它们在时钟信号的控制下保存和更新数据。

3. **程序计数器（PC）是一个寄存器**。
   - **正确**（T）：程序计数器（PC）保存当前指令的地址，并在每次指令执行后更新，以指向下一条指令。作为一个寄存器，PC 能够在每个时钟周期保存和更新地址值。

## Summary: Arithmetic/Logical Datapath

1. **所有数据线都携带信息**。
   - **解释**：在数据路径中，所有的信号线都传输有效的数据，无论是操作数、立即数还是地址。这些数据通过寄存器、ALU 和内存等硬件单元进行处理和传输。
   - **重要性**：确保数据路径中每一条数据线都能正确传输和处理数据，对于处理器的正确运行至关重要。
2. **控制逻辑决定什么是“有用/需要的”与“被忽略的”**。
   - **控制逻辑的作用**：控制逻辑通过解码指令，产生一系列控制信号，指导数据路径中的各个硬件单元执行相应的操作。例如：
     - **ALUSel**：选择 ALU 的操作类型，如加法、减法、按位与或按位或等。
     - **Bsel**：选择 ALU 输入 B 的来源，是来自寄存器的操作数还是来自指令的立即数。
3. **数据路径示意图**：

![image-20240804110247770]({{ site.baseurl }}/docs/assets/image-20240804110247770.png)

- **IMEM（指令存储器）**：根据程序计数器（PC）提供当前指令。
- **寄存器文件（RegFile）**：提供寄存器的操作数，并接收 ALU 的运算结果。
- **ALU**：执行算术和逻辑运算。

通过这个总结，我们可以看到数据路径和控制逻辑是如何协同工作的，以确保处理器能够正确执行指令。