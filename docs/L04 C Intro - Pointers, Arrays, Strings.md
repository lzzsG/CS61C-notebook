---
layout: page
title: L04 C Intro - Pointers, Arrays, Strings
permalink: /L04
nav_order: 4



---

# C语言入门 - 指针、数组、字符串

---

本节是 CS 61C L04 C Intro - Pointers, Arrays, Strings

### 什么是指针

首先，我们来介绍一种叫做指针的东西。根据你是否参加过61b课程，可能对指针的了解有所不同。如果你以前没有接触过指针，现在我们就来讲解。

在讲解指针之前，我希望你能考虑一个我们将在接下来的一到三周中使用的抽象概念：**内存是一个巨大的数组**。这意味着内存中的每一个字节都是可以寻址的。

### 内存和地址

假设我们从地址0开始，我在这里用十六进制表示。所以，我们有地址0，然后继续沿着这条线，可能到达地址100，接着是104，依此类推直到无穷。

注意这里有一个地址和值的区别。例如，在地址104，我们存储了值23。也许这是一个字节23的表示。

### 指针的定义

指针也是一种值。它存储的是一个地址值。这意味着我们可以用一个小箭头表示它指向某个地址，但实际存储的值是地址本身，例如104。

### 在C语言中声明和初始化指针

现在我们来看如何在C语言中使用星号操作符来声明和初始化指针。星号操作符有两种不同的使用方式。

#### 声明指针

```c
int *p;
```

这行代码声明了一个指针变量`p`。这个指针`p`会指向一个`int`类型的变量。

#### 初始化指针

假设我们声明了一个`int x`，并赋值为3：

```c
int x = 3;
```

这里`x`存储在地址104，值为3。注意，刚声明的指针`p`中存储的是垃圾值。我们要在`p`中存储一个值，具体来说是104。

我们使用&操作符来实现：

```c
p = &x;
```

这行代码中，&操作符表示取变量`x`的地址，然后将这个地址存储到指针`p`中。这样我们就可以认为`p`指向了这个地址，`p`中存储的值是104。

### 指针的用途

为什么指针有用呢？我们可以使用指针来访问它指向的地址处的值。例如：

```c
printf("%d\n", *p);
```

这行代码中，`*p`表示获取`p`指向的地址处的值。在这个例子中，`p`指向地址104，而地址104处的值是3，因此这行代码会打印出3。

我们也可以使用解引用操作符（`*`）来修改指针指向的地址处的值：

```c
*p = 5;
```

这行代码将`p`指向的地址处的值修改为5，所以`x`的值会从3变成5。

### 星号的双重用途

值得注意的是，星号操作符有两种不同的用法：

1. 在声明时使用，表示变量是一个指针。例如：

    ```c
    int *p;
    ```

2. 在解引用时使用，表示获取或设置指针指向的地址处的值。例如：

    ```c
    printf("%d\n", *p);
    *p = 5;
    ```

通过这些讲解，我们希望你能理解指针在C语言中的基本概念及其使用方法。指针在C语言中是一个非常强大和重要的工具，理解它将帮助你更好地掌握C语言。




---


## 为什么使用指针

### 值传递与引用传递的区别

你可能会问，为什么要使用指针？一个重要原因是函数参数的传递方式。像Java那样的语言通过值传递参数，而C语言也采用值传递。这意味着函数接收的是参数的副本。

#### 值传递的局限

举个例子，如果你想修改一个变量`y`的值，并直接传递它的值，那么函数内部接收到的是这个值的副本。例如：

```c
void foo(int x) {
    x = 4;
}
```

假设你调用`foo(y)`，如果`y`最初的值是3，传递进去后，`x`接收到的是3的副本。函数内部虽然将`x`修改为4，但返回后，`y`仍然是3。

#### 使用指针的优势

相反，如果我们使用指针传递`y`的地址：

```c
void foo(int *p) {
    *p = 4;
}
```

假设`y`的地址是100，传递进去后，`p`接收到的是地址100。通过解引用`*p`，我们访问到地址100处的值，将其修改为4。这样，函数返回后，`y`的值变为了4。

### 指针的高效性

C语言以其高效著称。如果每次都需要传递一个巨大的结构体或数组，而不得不复制所有的内存，那将会极大降低效率。因此，传递指针是一个更优的选择，因为指针仅仅是一个地址。

### 指针的历史背景

C语言诞生于上世纪70年代，当时编译器在处理内存性能问题上面临很多挑战。C语言通过指针这种间接访问的方法，给程序员提供了更多的灵活性。尽管如今的编译器和计算机性能已经大幅提升，但在低级性能优化方面，指针依然扮演着重要角色。

### 指针的风险

然而，指针也是C代码中错误的主要来源。尤其是在堆内存分配、动态内存管理和内存泄漏等方面，指针的使用需要特别小心。

### 常见的指针错误

#### 垃圾地址

当声明一个指针变量但没有初始化时，它可能包含垃圾值。例如：

```c
void f() {
    int *ptr;
    *ptr = 5;  // 可能修改内存中的任意位置
}
```

这个代码段中，`ptr`未初始化，可能指向内存中的任意位置，修改操作可能导致程序不可预测的行为。

### 指针与数据类型

指针可以指向任何数据类型。例如：

```c
int *int_ptr;
char *char_ptr;
struct my_struct *struct_ptr;
```

唯一的例外是`void*`，它是一种通用指针，能指向任何类型，但容易引发程序错误和安全漏洞。

### 函数指针

指针不仅可以指向数据，还可以指向函数。例如：

```c
int (*fn_ptr)(void*, void*);
```

这行代码声明了一个函数指针`fn_ptr`，它指向一个接收两个`void*`参数并返回`int`类型的函数。

函数指针的一个实际应用是实现高阶函数，例如`map`函数，可以接受一个函数作为参数，对数组中的每个元素应用该函数。

### 总结

理解并熟练使用指针是学习C语言的重要部分。指针不仅提高了代码的效率，也使代码更加紧凑。然而，指针使用不当会导致严重的错误。通过这次讲解，希望你对指针有了更深入的了解，并能在实际编程中安全有效地使用它们。


---



## 无效指针与空指针

### 什么是无效指针

在C语言中，确实存在无效指针的概念。无效指针指的是那些指向未分配或无法访问内存地址的指针。

### 空指针

C语言使用一种约定：如果指针的值为全零，即指针存储地址为0，这就称为空指针（null pointer）。这与Java和Python中的空指针类似，但在C语言中，它实际上是存储地址为0。空指针允许我们检查一个指针是否为空。

#### 空指针的特点

如果一个指针存储的地址为0，那么这个地址是无法读写的。每当尝试读写空指针时，程序应该崩溃，这是C语言内部实现的机制，也是编译器所遵循的契约。

## 结构体与指针

在第一个项目中（如实现贪吃蛇游戏），我们会大量使用结构体（structs）。这里复习一下结构体的概念：

### 结构体的定义

假设我们定义一个结构体`Coord`，其中包含两个值`x`和`y`：

```c
typedef struct {
    int x;
    int y;
} Coord;
```

我们可以声明结构体变量或结构体指针：

```c
Coord coord1, coord2;
Coord *ptr1, *ptr2;
```

### 结构体指针的操作

对于结构体变量，我们使用点号（`.`）访问成员：

```c
coord1.x = 10;
coord1.y = 20;
```

对于结构体指针，我们使用箭头符号（`->`）访问成员：

```c
ptr1->x = 10;
ptr1->y = 20;
```

箭头符号是点号操作符的简写形式：

```c
(*ptr1).x = 10;
(*ptr1).y = 20;
```

### 指针赋值

以下代码片段展示了指针赋值的操作：

```c
ptr1 = ptr2;
```

如果`ptr2`指向一个已经初始化的结构体，那么`ptr1 = ptr2`表示`ptr1`现在指向`ptr2`指向的同一个地址。简单来说，指针赋值操作将一个指针的值（即地址）复制到另一个指针中。

### 抽象的力量

在理解指针时，可以用不同的方式进行抽象：

1. 以地址的形式理解：每个指针存储一个地址值。
2. 以箭头的形式理解：指针指向一个内存位置。

无论哪种方式，只要你感到舒适并能够正确使用指针，都是有效的理解方式。这也是抽象的力量所在。

通过这些讲解，希望你对无效指针、空指针及结构体指针有了更深入的理解。掌握这些概念对于写出高效、健壮的C代码至关重要。




----




## 指针运算与数组

在深入讲解数组之前，我们先来讨论指针运算。指针运算与数组的使用密切相关，是C语言中一个非常重要的概念。

### 指针运算

C语言中的指针运算允许我们通过加减操作来改变指针所指向的地址。这与数组的操作有着紧密的联系。

#### 数组的定义与初始化

在C语言中，数组实际上是一个大块的连续内存。与Java和Python不同，C语言的数组是直接操作内存的。

例如，以下代码声明并初始化一个包含两个整数的数组：

```c
int array[2] = {1, 2};
```

这个数组在内存中连续存储两个整数。

#### 访问数组元素

我们可以通过索引访问数组元素：

```c
int value = array[0];  // 访问第一个元素，值为1
```

实际上，这里的数组访问是通过指针运算实现的。数组名实际上是一个指向数组首元素的指针。

#### 指针与数组的关系

假设我们有一个指向数组首元素的指针`q`：

```c
int *q = array;
```

我们可以通过指针运算访问数组元素：

```c
int value = *(q + 1);  // 访问第二个元素，值为2
```

指针运算中，`q + 1`表示指针移动一个整数的大小（4字节），然后通过解引用操作符`*`访问该地址处的值。

### 指针运算的细节

指针运算根据指针类型的大小进行偏移。例如，对于`int`类型指针，`q + 1`表示指针移动4字节。

```c
int array[3] = {50, 60, 70};
int *q = array;
```

此时，`q`指向数组的第一个元素（值为50）。通过指针运算，我们可以访问和修改数组中的元素：

```c
*(q + 1) = 60;  // 访问并修改第二个元素
```

### 双重指针

当需要在函数中修改指针本身时，我们会用到双重指针，即指向指针的指针。

#### 使用双重指针修改指针

以下示例展示了如何通过双重指针修改指针：

```c
void increment

### 使用双重指针修改指针

以下示例展示了如何通过双重指针修改指针：

```c
void increment_pointer(int **p) {
    *p = *p + 1;
}

int main() {
    int array[3] = {50, 60, 70};
    int *q = array;
    increment_pointer(&q);
    printf("%d\n", *q);  // 输出60
    return 0;
}
```

在这个示例中，`increment_pointer`函数接收一个指向指针的指针`p`。通过解引用`*p`，我们访问并修改了传入的指针`q`的值，使其指向下一个数组元素。

## 总结

### 指针运算与数组

1. **指针运算**：通过加减操作改变指针的地址。对于`int`类型指针，`q + 1`表示指针移动4字节。
2. **数组与指针的关系**：数组名实际上是一个指向数组首元素的指针，可以通过指针运算访问数组元素。
3. **双重指针**：用于在函数中修改指针本身，通过传递指向指针的指针实现。

理解并掌握指针运算、数组以及双重指针是C语言编程的重要技能。它们不仅提高了代码的效率，也为复杂数据结构的实现提供了强大的工具。通过以上讲解，希望你能更深入地理解这些概念，并能在实际编程中灵活应用。




----




## 数组陷阱

### 数组大小问题

许多人喜欢使用数组，但数组也有一些常见的陷阱。第一个陷阱是关于数组大小的。经常会有人倾向于声明一个固定大小的数组，例如大小为10的数组，然后在循环中填充数组元素：

```c
int array[10];
for (int i = 0; i < 10; i++) {
    array[i] = i;
}
```

尽管这种做法可以编译并运行，但它容易导致错误。我们建议的更好的做法是只声明一次数组大小，并在整个代码中使用这个大小来声明数组和进行循环：

```c
#define ARRAY_SIZE 10
int array[ARRAY_SIZE];
for (int i = 0; i < ARRAY_SIZE; i++) {
    array[i] = i;
}
```

这种方法不仅避免了重复定义，而且减少了维护多个副本的风险，有助于提高代码的可读性和可维护性。

### 数组与指针的区别

数组与指针在C语言中几乎是相同的，但它们并不完全相同。例如：

```c
char *str1 = "hello";
char str2[] = "hello";
```

`str1`是一个指向字符的指针，而`str2`是一个字符数组。虽然两者看起来类似，但在底层实现和使用上有一些关键差异。

#### 指针与数组的等效性

数组名实际上是指向数组首元素的指针。因此，可以通过数组名和指针来访问数组元素：

```c
int array[3] = {1, 2, 3};
int *p = array;
printf("%d\n", p[0]);  // 输出1
printf("%d\n", *p);    // 输出1
```

上述两种方式在效果上是相同的。

### 数组与指针的不同点

虽然数组名可以用作指针，但它们在某些情况下行为不同。例如，获取数组名的地址与获取指针变量的地址是不同的：

```c
int array[3] = {1, 2, 3};
int *p = array;
printf("%p\n", (void *)array);    // 输出数组首元素的地址
printf("%p\n", (void *)&array);   // 输出数组整体的地址
printf("%p\n", (void *)&p);       // 输出指针变量p的地址
```

数组名和数组的地址是相同的，但指针变量的地址与它所指向的地址不同。

### 动态内存分配

在C语言中，数组大小是固定的，一旦声明就不能改变。如果需要动态调整数组的大小，可以使用动态内存分配：

```c
int *array = malloc(2 * sizeof(int));
array[0] = 1;
array[1] = 2;
array = realloc(array, 4 * sizeof(int));
array[2] = 3;
array[3] = 4;
```

使用`malloc`和`realloc`函数可以动态分配和调整数组的大小，但需要注意手动释放内存以避免内存泄漏：

```c
free(array);
```

## 总结

### 数组陷阱总结

1. **数组大小问题**：建议使用常量或宏定义数组大小，以避免重复定义和维护多个副本的风险。
2. **数组与指针的区别**：尽管数组名可以用作指针，但在底层实现和使用上存在差异，需要理解和注意。
3. **动态内存分配**：数组大小固定，不能在声明后改变。使用`malloc`和`realloc`可以实现动态内存分配，但需要手动管理内存。

通过理解和避免这些常见的数组陷阱，可以提高代码的可靠性和可维护性。这对于编写健壮的C语言程序非常重要。




-----



## 数组的陷阱

### 数组边界未检查

数组在C语言中并不是真正的数据结构，而只是大块的内存。其原始特性容易导致某些错误。第一个常见的错误是数组边界未检查。例如，我们声明一个大小为100的数组，然后试图访问第101个元素：

```c
int array[100];
array[100] = 123;  // 超出数组边界
```

这段代码虽然可以编译，但在运行时可能会导致程序崩溃或其他部分的内存被篡改，因为C语言不会自动检查数组边界。这种错误被称为缓冲区溢出（buffer overflow），在实际应用中可能会导致严重的安全漏洞，例如远程攻击者可以执行任意代码或造成拒绝服务（DoS）攻击。

### 数组作为函数参数传递

数组在作为函数参数传递时，其行为与指针类似。尽管C语言是通过值传递参数，但数组会衰减为指向其首元素的指针。例如：

```c
void func(int arr[], unsigned int size) {
    // arr 被视为指针
}
```

在调用函数时：

```c
int array[10];
func(array, 10);
```

在函数内部，`arr`实际上是一个指向`array`首元素的指针，而不是整个数组的副本。因此，必须显式地传递数组的大小，以便函数知道数组的长度。

### 指针算术运算

指针算术运算允许我们通过加减操作来改变指针所指向的地址。例如：

```c
int array[3] = {10, 20, 30};
int *p = array;
printf("%d\n", *(p + 1));  // 输出20
```

这里，`p + 1`表示指针移动一个`int`的大小（4字节），然后通过解引用操作符`*`访问该地址处的值。

### 动态内存分配

当需要在运行时动态调整数组的大小时，可以使用动态内存分配。例如：

```c
int *array = malloc(2 * sizeof(int));
array[0] = 1;
array[1] = 2;
array = realloc(array, 4 * sizeof(int));
array[2] = 3;
array[3] = 4;
```

使用`malloc`和`realloc`函数可以动态分配和调整数组的大小，但需要注意手动释放内存以避免内存泄漏：

```c
free(array);
```

### 数组的作用域

数组在函数内声明时，其生命周期仅在函数作用域内有效。如果返回一个局部数组的地址，会导致指针指向无效的内存区域：

```c
char* createArray() {
    char arr[10];
    return arr;  // 返回无效指针
}
```

正确的方法是使用动态内存分配：

```c
char* createArray() {
    char *arr = malloc(10 * sizeof(char));
    return arr;
}
```

### 数组与指针的区别

数组名可以用作指针，但在底层实现和使用上存在差异。例如，获取数组名的地址与获取指针变量的地址是不同的：

```c
int array[3] = {1, 2, 3};
int *p = array;
printf("%p\n", (void *)array);    // 输出数组首元素的地址
printf("%p\n", (void *)&array);   // 输出数组整体的地址
printf("%p\n", (void *)&p);       // 输出指针变量p的地址
```

数组名和数组的地址是相同的，但指针变量的地址与它所指向的地址不同。

### 总结

数组在C语言中虽然是一个常见且有用的数据结构，但其原始特性和行为需要特别注意。理解和避免这些常见的数组陷阱，可以提高代码的可靠性和可维护性。这对于编写健壮的C语言程序非常重要。在下一次讲解中，我们将深入探讨内存结构，特别是栈和堆的区别，以及如何有效地管理内存。



---




## 地址的有效性与错误

### 无效地址

在C语言中，不是所有的内存地址都是有效的。即使我们假设内存从0到无穷大连续分布，但实际上存在两种主要的错误与地址相关：

1. **段错误（Segmentation Fault）**：当程序试图访问未分配或无权限访问的内存区域时，就会发生段错误。这种错误通常在运行时才会被发现，并导致程序崩溃。例如，尝试访问已经释放的内存或超出数组边界访问内存都会引发段错误。
   
2. **总线错误（Bus Error）**：当程序试图访问未对齐的内存地址时，就会发生总线错误。例如，一个`int`型指针指向了一个非`int`型地址（比如`int`型地址加1字节），这种情况可能导致总线错误。总线错误也是一个运行时错误，具体情况取决于硬件架构和操作系统。

### 空指针和无效指针

空指针（null pointer）是一个特殊的指针，值为0，表示它不指向任何有效的内存地址。在C语言中，空指针无法被读写，任何对空指针的访问都会导致程序崩溃。除了空指针，指向无效地址的指针也会导致类似的问题。

## C语言中的字符串

### 字符串的表示

在C语言中，字符串实际上是以`\0`（null terminator）结尾的字符数组。例如：

```c
char str[] = "ABC";
```

这个声明创建了一个包含4个字符的数组，其中最后一个字符是`'\0'`。这种表示方式使得C语言的字符串可以使用标准库中的函数进行操作，例如计算字符串长度、拼接字符串等。

### 字符串操作

由于C字符串以null terminator结束，标准库函数如`strlen`会遍历数组直到遇到`'\0'`为止。因此，字符串操作时需要注意以下几点：

1. **字符串长度**：`strlen`返回的长度不包括null terminator。
2. **字符串复制**：使用`strcpy`时需要确保目标数组有足够的空间容纳源字符串和null terminator。

## 内存对齐

### 什么是内存对齐

内存对齐是指数据在内存中存储时，以特定的边界对齐。大多数计算机架构要求数据按其大小对齐，以提高内存访问效率。例如，在32位架构中，`int`型数据需要以4字节边界对齐。

### 内存对齐的示例

假设我们在一个32位架构中，内存地址如下排列：

```plaintext
地址：   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
字节：  00   01   02   03   04   05   06   07   08   09   0A   0B   0C   0D   0E   0F
```

在这种情况下，`int`型数据（占用4字节）必须存储在能被4整除的地址（如0、4、8等）上。若试图在非对齐地址存储数据，会引发总线错误。

### 指针的大小

在32位系统中，指针的大小为4字节，因为它们需要能够表示0到`2^32 - 1`之间的任意地址。

## 动态内存分配

### 堆与栈的区别

- **栈（Stack）**：用于存储函数调用时的局部变量，内存由系统自动分配和释放。当函数返回时，局部变量占用的内存被自动回收。
  
- **堆（Heap）**：用于动态分配内存，由程序员手动管理（分配和释放）。动态内存在函数返回后仍然存在，直到程序显式释放它。

### 动态内存分配示例

使用`malloc`、`realloc`和`free`函数可以动态管理内存。例如：

```c
int *array = malloc(2 * sizeof(int));
array[0] = 1;
array[1] = 2;
array = realloc(array, 4 * sizeof(int));
array[2] = 3;
array[3] = 4;
free(array);
```

在这个示例中，我们首先分配了一个包含2个`int`的数组，然后重新分配内存以扩展数组，并最终释放内存。

## 总结

理解C语言中的地址有效性、字符串表示、内存对齐和动态内存分配是编写健壮C程序的关键。这些知识不仅有助于提高代码效率，还能避免常见的内存错误。在下一次讲解中，我们将进一步探讨内存结构，特别是堆和栈的管理及其区别。




---



## 字长与内存对齐

### 字长的重要性

字长（Word Size）对CPU和计算机架构的工作方式至关重要。在C语言中，指针类型声明不仅告诉编译器要获取多少字节，还指示变量本身需要字对齐。

例如：
- `int`类型在32位系统中占4字节，指针指向某个地址，并从该地址开始获取4字节，构成一个32位整数。
- `short`类型占2字节，从指针所指地址开始获取2字节，构成一个16位短整数。
- `char`类型占1字节，从指针所指地址开始获取1字节，构成一个字符。

### 内存对齐

内存对齐要求所有变量的地址都必须是字长的倍数。例如，32位系统中，所有变量地址必须是4的倍数。这种对齐方式虽然会造成一些内存浪费，但能显著提升CPU访问内存的效率。

### 结构体中的对齐与填充

结构体是将多种数据类型组合在一起的一种方式，但这种组合会影响内存的布局。下面是一个包含`int`、`char`和指针的结构体示例：

```c
struct Foo {
    int a;
    char b;
    struct Foo* ptr;
};
```

这个结构体在内存中的布局如下：
- `int`占4字节
- `char`占1字节
- 由于指针需要对齐到4字节，所以在`char`之后会有3字节的填充
- 指针占4字节

因此，这个结构体总共占用12字节，其中包含填充字节。

## 内存地址的有效性

### 段错误（Segmentation Fault）

段错误是在程序试图访问未分配或无权限访问的内存区域时发生的。例如，访问已释放的内存或数组越界访问都会导致段错误。

### 总线错误（Bus Error）

总线错误是程序试图访问未对齐的内存地址时发生的。例如，一个`int`型指针指向了一个非`int`型地址。总线错误通常取决于硬件架构和操作系统。

### 空指针与无效指针

空指针（null pointer）是一个特殊的指针，值为0，表示它不指向任何有效的内存地址。访问空指针会导致程序崩溃。其他无效指针也会引发类似问题。

## C语言中的字符串

### 字符串的表示

在C语言中，字符串是以null终止符（`\0`）结尾的字符数组。例如：

```c
char str[] = "ABC";
```

这个声明创建了一个包含4个字符的数组，其中最后一个字符是`'\0'`。这种表示方式使得字符串操作可以使用标准库函数进行，例如计算字符串长度（`strlen`）和拼接字符串（`strcat`）等。

### 字符串操作

由于C字符串以null终止符结束，标准库函数如`strlen`会遍历数组直到遇到`'\0'`为止。因此，字符串操作时需要注意以下几点：
- `strlen`返回的长度不包括null终止符。
- 使用`strcpy`时需要确保目标数组有足够的空间容纳源字符串和null终止符。

## 动态内存分配

### 堆与栈的区别

- **栈（Stack）**：用于存储函数调用时的局部变量，内存由系统自动分配和释放。当函数返回时，局部变量占用的内存被自动回收。
- **堆（Heap）**：用于动态分配内存，由程序员手动管理（分配和释放）。动态内存在函数返回后仍然存在，直到程序显式释放它。

### 动态内存分配示例

使用`malloc`、`realloc`和`free`函数可以动态管理内存。例如：

```c
int *array = malloc(2 * sizeof(int));
array[0] = 1;
array[1] = 2;
array = realloc(array, 4 * sizeof(int));
array[2] = 3;
array[3] = 4;
free(array);
```

在这个示例中，我们首先分配了一个包含2个`int`的数组，然后重新分配内存以扩展数组，并最终释放内存。

## 内存对齐与字节序

### 字节序

字节序指的是数据在内存中的存储顺序。主要有两种：
- **小端序（Little Endian）**：最低有效字节存储在最低地址。
- **大端序（Big Endian）**：最高有效字节存储在最低地址。

例如，32位整数`0x12345678`在小端序系统中存储为`78 56 34 12`，在大端序系统中存储为`12 34 56 78`。

### 示例

假设有一个指针指向地址`0xF0`，存储的值为`0x12345678`，在小端序系统中的内存布局如下：

```plaintext
地址：   F0   F1   F2   F3
值：   78   56   34   12
```

### 内存对齐示例

在32位架构中，指针的大小为4字节，因为它们需要能够表示0到`2^32 - 1`之间的任意地址。内存对齐要求变量的地址必须是字长的倍数。例如：

```c
int *ptr = (int*)0xF0;  // 对齐到4字节边界
```

### 结束语

理解C语言中的字长、内存对齐、地址有效性和动态内存分配等概念对于编写健壮的程序至关重要。这些知识不仅有助于提高代码的效率，还能避免常见的内存错误。在下一次讲解中，我们将进一步探讨内存管理和高级编程技巧。