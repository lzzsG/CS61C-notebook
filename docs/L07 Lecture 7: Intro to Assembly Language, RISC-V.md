---
layout: page
title: L07 Intro to Assembly Language, RISC-V
permalink: /L07
nav_order: 7

---

# Lecture 7: Intro to Assembly Language, RISC-V

# Floating Point Discussion

## Floating Point Fallacy

### 浮点数谬误

**浮点数加法具有结合性吗？**

**示例：**

```plaintext
x = -1.5 × 10^38
y = 1.5 × 10^38
z = 1.0

x + (y + z) = -1.5 × 10^38 + (1.5 × 10^38 + 1.0)
             = -1.5 × 10^38 + 1.5 × 10^38
             = 0.0

(x + y) + z = (-1.5 × 10^38 + 1.5 × 10^38) + 1.0
             = 0.0 + 1.0
             = 1.0
```

**结论：**

浮点数加法不具有结合性。结合性是指运算顺序不影响结果的性质。在这个例子中，不同的加法顺序得出了不同的结果。

**原因：**

- 浮点数的表示是近似的，可能会导致精度损失。
- 当数值的差异很大时，较小的数可能被忽略。
- 在示例中， \\(1.5 \times 10^{38}\\) 远大于 1.0，因此 \\(1.5 \times 10^{38} + 1.0\\) 被近似为 \\(1.5 \times 10^{38}\\)。

## Rounding

### 舍入

**在进行浮点运算时，必须对结果进行舍入以适应有限的有效数字字段。**

**浮点硬件通常会保留额外的两位精度，然后进行舍入，以获得更精确的结果。**

**舍入还会在以下情况下发生：**

- 从双精度值转换为单精度值。
- 从浮点数转换为整数。

## IEEE FP’s Four Rounding Modes

### IEEE 浮点数的四种舍入模式

**向 +∞ 舍入：**

- 总是向上舍入：2.001 → 3，-2.001 → -2

**向 -∞ 舍入：**

- 总是向下舍入：1.999 → 1，-1.999 → -2

**截断（Truncate）：**

- 只删除最后的位（向0舍入）。

**无偏舍入（默认）：如果中间值，则向偶数舍入：**

- 正常舍入：2.4 → 2，2.6 → 3
- 中间值向偶数舍入：2.5 → 2，3.5 → 4
- 这种方法确保计算的公平性，平衡了不准确性：
  - 当值正好在边界上时，一半时间向上舍入，另一半时间向下舍入。

**总结**

**浮点数加法的非结合性：**

- 浮点数在计算过程中会出现精度损失，尤其是当操作数的数量级差异很大时。
- 在示例中，由于 \\(1.5 \times 10^{38}\\) 远大于 1.0，浮点数的表示会导致 \\(1.5 \times 10^{38} + 1.0\\) 被近似为 \\(1.5 \times 10^{38}\\)，从而忽略了 1.0 的影响。

**舍入模式的作用：**

- 舍入模式的选择对计算结果有直接影响，不同的模式在不同的应用场景中有不同的用途。
- **向 +∞ 舍入** 和 **向 -∞ 舍入** 在金融计算或误差控制中有特定的应用。
- **截断（Truncate）** 在某些算法中用于快速计算。
- **无偏舍入**（向偶数舍入）则是为了减少系统性误差，广泛用于通用计算中。



## FP Addition

### 浮点数加法

浮点数加法比整数加法更复杂，不能直接相加有效数字。

**我们如何进行浮点数加法？**

1. **去规范化以匹配指数**：
   - 首先将两个浮点数的指数调整到相同的值。选择较大的指数，并将较小指数的数进行相应的调整。
2. **将有效数字相加**：
   - 调整后的两个浮点数的有效数字相加。如果符号不同，执行减法。
3. **保持匹配的指数**：
   - 加法或减法后，保持之前选择的较大指数。
4. **规范化（可能更改指数）**：
   - 如果结果的有效数字不符合规范化形式，需要调整，使结果成为规范化浮点数，可能需要更改指数。

**注意：** 如果符号不同，只需进行减法。

### 详细示例

假设我们要计算：

\\[ A = 1.25 \times 10^3 \\]
\\[ B = 2.75 \times 10^2 \\]

1. **去规范化**：调整B的指数与A相同
\\[ B = 0.275 \times 10^3 \\]

2. **有效数字相加**：
\\[ A + B = 1.25 \times 10^3 + 0.275 \times 10^3 = 1.525 \times 10^3 \\]

3. **保持匹配的指数**：
\\[ 1.525 \times 10^3 \\]

4. **规范化**：
   - 结果已经是规范化形式，不需要进一步调整。

## Casting floats to ints and vice versa

### 浮点数和整数之间的类型转换

在C语言中，可以通过强制类型转换来进行浮点数和整数之间的转换。

**将浮点数转换为整数：**

```c
(int) floating_point_expression
```

- 将浮点数转换为最接近的整数（C语言使用截断）。
- 例如：

```c
int i;
float f = 3.14159;
i = (int) f; // i的值为3
```

**将整数转换为浮点数：**

```c
(float) integer_expression
```

- 将整数转换为最接近的浮点数。
- 例如：

```c
int i = 5;
float f;
f = (float) i; // f的值为5.0
```

## Double Casting Doesn’t Always Work

### 双重类型转换并不总是有效

以下示例说明了浮点数和整数之间的双重类型转换并不总是有效：

```c
int i = ...;
if (i == (int)((float) i))
{
    printf("true");
}
```

- **不会总是打印“true”！**
  - 大多数大整数值没有精确的浮点数表示。
  - 回忆：每个指数只有 \\(2^{23}\\) 个浮点数。

**双精度呢？**

```c
float f = ...;
if (f == (float)((int) f))
{
    printf("true");
}
```

- **不会总是打印“true”！**
  - 小浮点数（<1）没有整数表示。
  - 对于其他数字，舍入错误可能导致结果不准确。

**总结**

- 浮点数的表示是有限精度的。对于非常大的整数，浮点数可能无法精确表示，导致转换回整数时出现误差。
- 例如，一个非常大的整数可能被转换为一个近似的浮点数，而再转换回整数时，由于精度限制，结果可能不同。
- 类似地，小浮点数（小于1）在转换为整数时会被截断为零，再转换回浮点数时就变成了零。

---

# The RISC-V Instruction Set Architecture